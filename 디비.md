- char varchar 차이
    
    char(50) varchar(50) 하고 'ABC'를 넣으면
    
    char는 고정길이 문자열타입이기 때문에 ABC넣고 남은 빈공간을 공백으로 다 채움. 그리고 헤더에는 레코드 길이에 대한 정보가 들어있지 않음
    
     varchar 가변길이 문자열타입으로 이후공간은 공백을 채우지 않는다. 헤더에 레코드 길이에 대한 정보가 포함되어있음
    
    - char(n) 에서 n은 바이트가 아니라 글자 수를 의미
        
        최대길이 255
        
        - char 장점
            
            고정 사이즈라서 추후에 연산할 필요가 없기 때문에 검색속도 및 읽는 속도가 다른 타입보다 빠르다. (아이디, 주민등록번호..)
            
    - varchar
        
        65,535 까지 길이 가능
        
        길이에 대한 정보를 저장하는 byte필요
        
        255 이하는 1byte, 이상은 2byte의 추가 크기가 필요하다.
        
        예를 들어 VARCHAR(10)에 ‘test’라는 4자짜리 문자열을 삽입하면 4byte + **1byte(길이를 저장하기 위한 메모리)** = 5byte가 소모된다.
        
    
    고정공간을 만들어 놓았다가 빈 공간에 대한 비용이 더 큰 경우가 생길 수 있으므로 저는 VARCHAR
    
- Delete truncate drop
    
    **1.Delete**
    
    - 데이터만 삭제 되며 테이블 용량은 줄어 들지 않는다. 또한 삭제후 잘못 삭제한 것을 되돌릴 수 있다.
    - TABLE이나 CLUSTER에 행이 많으면 행이 삭제될 때마다 많은 SYSTEM 자원이 소모 된다.
    - Commit이전에는 Rollback이 가능하다.
    - 롤백정보를 기록 하므로 Truncate에 비해서 느리다.전체 또는 일부만 삭제 가능 하다.
    - 삭제 행수를 반환 한다.
    - 데이터를 모두 Delete해도 사용했던 Storage는 Release 처리 되지 않는다.
    
    **2.Truncate - 테이블의 모든 로우를 제거하는 Truncate Table**
    
    테이블을 최초 생성된 초기상태로 만든다.
    
    용량이 줄어들고, 인덱스 등도 모두 삭제 된다.
    
    Rollback 불가능 하다.- 무조건 전체 삭제만 가능 하다.
    
    삭제 행수를 반환 하지 않는다.
    
    테이블이 사용했던 Storage중 최초 테이블 생성시 할당된 Storage만 남기고 Release 처리 된다.
    
    **3. Drop table - 테이블 구조를 제거**
    
    기존 테이블의 존재를 제한다. (테이블의 정의 자체를 완전히 삭제한다)
    
    Rollback 불가능 하다.
    
    테이블이 사용했던 Storage는 모두 Release 처리 된다.
    
- **이상현상이란?**
    
    릴레이션에서 일부 속성들의 종속으로 인해 데이터 중복이 발생하는 것 (insert, update, delete)
    
- 조인
    - 정의
        
        2개 이상의 테이블을 서로 관계를 맺어서 데이터를 추출하는 방법
        
        두 개 이상의 테이블을 서로 묶어서 하나의 결과 집합으로 만들어 내는 것   ㅡ  테이블 간의 연결 고리로 관계를 맺고 데이터를 추출 해야 하는 작업
        
    - 장점
        
        테이블을 여러 번 읽을 필요가 없고 트랜잭션 보호가 가능
        
    - 동등 조인 EQUI JOIN
        
        WHERE 절에서 = 연산자를 사용해 2개 이상의 테이블이나 피를 연결한 조인이다 집 = 연산자를 사용한 WHERE 절 조건을 만족 하는 데이터를 추출 하는 조인
        
    - 세미 조인
        
        서브 커리를 사용해서 보컬이 의 존재 하는 데이터만 메인거리에서 추출 하는 좋은 방법으로 IN 과 EXISTS 연산자를 사용한 조인
        
        서브 쿼리에 있는 테이블을 B, 메인 쿼리에 사용된 테이블을 A 라고 한다면 세미 조인 B테이블에 존재하는 A테이블의 데이터를 추출 하는 조인
        
    - INNER JOIN
        
        정의 - 양쪽 테이블에 모두 내용이 있는 것만 조인되는 방식 (교집합)
        
    - OUTER JOIN
        
        정의 - 양쪽에 내용과 한쪽에만 내용이 있어도 결과가 표시되는 조인 방식 / 조인의 조건에 만족되지 않는 행까지도 포함시킴
        
        - LEFT OUTER JOIN
            
            정의 - 왼쪽 테이블(FROM 절의 테이블)의 것은 모두 출력 (조건에 만족되지 않는 결과도 출력)
            
            ```sql
            SELECT U.userId, U.userName, B.prodName, U.addr, U.mobile1 AS "연락처"
            	FROM **userTbl U**  <---- 테이블 기준
            		LEFT OUTER JOIN **buyTbl B**
            			ON U.userID = B.userID
            	ORDER BY U.userID;
            ------
            	FROM **buyTbl B**
            		RIGHT OUTER JOIN **userTbl U**   <---- 테이블 기준
            			ON U.userID = B.userID
            	ORDER BY U.userID;
            
            ```
            
        - RIGHT OUTER JOIN
            
            정의 - 오른쪽 테이블의 것은 모두 출력
            
        - FULL OUTER JOIN
            
            정의 - LEFT, RIGHT OUTER JOIN이 합쳐진 것. 한쪽을 기준으로 조건과 일치하지 않는 것을 출력하는 것이 아니라, 양쪽 모두에 조건이 일치자히 않는 것을 모두 출력하는 개념
            
            UNION과 같은 개념으로 중복데이터 삭제
            
    - SELF JOIN (자체 조인)
        
        동일 테이블 사이의 조인
        
        자기 자신과 자기 자신이 조인.  하나의 테이블에 같은 데이터가 존재하되 의미는 다르게 존재하는 경우에는 두 테이블을 서로 SELF JOIN 시켜서 정보를 확인할 수 있다.
        
    - NESTED LOOP JOIN
        
        중첩 포문과 같은 원리.
        
        IDOL_GROUP IDOL_MEMBER를 조인할때 GROUP_NAME 컬럼 으로 연결
        소녀시대    -    소녀시대 멤버
        
        태연 찾고 써니찾고 티파니찾고 다 찾았다
        
        2ne1 row 에 조인될만한 산다라박 박봄 .. 다 찾았다
        
        또.. 다음 row 다음 그룹을 선택함
        
        IDOL_GROUP 이 OUTER TABLE  IDOL_MEMBER가 INNER TABLE
        
        INNER TABLE이 JOIN  컬럼이 인덱스에 걸려있지 않으면 굉장한 비효일이 발생하게 된다. 왜냐면 한건한건 갈때마다 full scan을 해야한다. 소녀시대가서 full scan으로 찾아야하고 2ne1가서 full scan으로 찾아야하는 상황이 발생하기 때문에 Inner Table의 인덱스 구성 전력이 매우 중요한 요소가 됨.
        
        건별로 계속 JOIN을 하는 방식이기 때문에 대량의 테이블을 JOIN하는 방식으로는 적절하지 않다. 보통은 OLTP성 환경의 쿼리가 적절. 아까의 예제 테이블은 1:M 관계였는데 1쪽에 해당하는 소량의 데이터를 가진 테이블이 OUTER TABLE로 설정되는것이 성능에 유리함.
        
    - SORT MERGE JOIN
        
        중첩 for문과 유사한 방식이지만 테이블과 테이블을 우선 JOIN 컬럼을 기준으로 sorting을하고 JOIN을함.
        
        Innter table에 적적한 인덱스가 없어서 NESTED LOOP JOIN쓰기에 비효율적일 떄 쓰고 아니면 Equl JOIN이 아니라 범위로 JOIN을 하는 경우에 이런 쿼리에서도 적절한 수행원리라고할 수 있음
        
        Table random access가 일어나지 않고 sorting 작업이PGA영역에서 수행되기 때문에 경합이 발생하지 않아서 성능에 유리한 이점이 있다.
        
    - HASH JOIN
        
        배치에 쓰면 좋은 수행 원리.
        
        대용량 테이블을 JOIN할 떄 HASH JOIN을 이용하면 좋다.
        
        IDOL_GROUP IDOL_MEMBER 있을떄 MEMBER테이블이 대용량테이블 일경우 GROUP 테이블을 Build Input으로 삼아서 HASH영역에 저장해놓는걱에요.
        
        HASH영역은 아까 SORT MERGE JOIN에서 잠깐 얘기햇던 Sort Area처럼 PGA에 있기떄문에 처리 속도가 빠르고, IDOL_GROUP 테이블이 HASH영역에 올라가고 IDOL_MEMBER테이블이 읽히면서 JOIN이 되는 원리.
        
        HASH영역으로 올라갈 떄는 JOIN  컬럼을 기준으로 HAsh Fuction이 적용이 되기때문에 이 Key값에 중복값이 없을수록 성능에 유리. 
        
        Equl JOIN만 가능하고 SORT MERGE JOIN처럼 Random Access부하가 없고 유의할점은 Hash영역에 들어갈 테이블의 크기가 충분히 작아야지 성능에 유리하다. 왜냐하면 Hash영역의 사이즈가 정해져잇는데 이 테이블의 용량이 초과해서 벗어나게 되면 오히려 디스크 영역을 사용하게 되기때문에 성능에 불리하게 됨. 그리고 수행빈도가 높은 OLTP환경에서 Hash JOIN으로 풀리게 되면 오히려 CPU나 메모리의 사용량이 늘어서 성능이 나빠질 수 있기때문에 이런 경우는 실행계획을 확인해보고 Hash JOIN을 풀리면 안되는데 HashJOIN으로 풀리고있다하면 힌트를 써서 다른 수행 방식으로 풀릴 수 있도록 유도를 하는게 효과적인 튜닝의 방법.
        
    - 실행계획
        
        내가 작성한 JOIN쿼리가 어떤 수행원리로 풀리고 있는지 궁금하면 실행계획을 보면됨 
        
        이 쿼리에는 이 수행원리가 적절하지 않는데 라고 판단이 되면 오라클 힌트를 써서 다른 수행방식으로 한번 유도를 해봐라 그리고 다시 수행계획을 보고 IO량이나 실행시간이 얼마나 변화하는지를 보고서 더 성능에 좋은 방향으로 튜닝을 하면 된다.
        
    - 힌트
        
        옵티마이저가 올바른 실행계획을 생성할 수 있도록 도움을 주는 것
        
        쿼리 작성단계에서 힌투를 준다기 보다는 튜닝 단계에서 많이 힌트를 주게 되어있음
        
        to 옵티마이저
        
        실행계획에 영향을 미치게 됨
        
        이 쿼리를 내부적으로 수행하는데 있어서 이런 방식으로 풀어라 이렇게 힌트를 주는거라서
        
        힌트를 주기전에 지금 이 쿼리가 어떤 방식으로 실행이 되고있는지를 실행계획으로 확인한다. 그래서 만약에 이 쿼리의 테이블에 적절한 인덱스가 생성이 되어있는데도 불구하고 옵티마이저가 잘못된 통계 등으로 인해서 이게 인덱스를 타지 않고 풀스캔을 타고 있다. 라고 했을때는 힌트를 줘서 이 테이블에는 이 인덱스를 사용해라 라는 식의 가이드를 옵티마이저에게 줄 수가 있다. 약간 강제성을 띰 또 조인순서, 조인방식을 바꾸게 ㄱㄴ
        
        - 유의해야하는점
            
            기본적으로는 힌트를 사용하지 않는게 좋다. 왜냐하면 옵티마이저가 기본적으로 올바른 판단을 할 거라는 전제하에 쿼리를 작성해야 되기 때문에 굳이 처음부터 힌트를 줄 필요는 없고 쿼리를 작성하고 실행계획을 확인했을때 이게 예상치보다 너무나 많은 I/O가 생긴다던지 시간이 많이 걸린다던지 하는 경우에 실행계획의 어느 구간에서 부하가 걸리는지를 확인하고 왜 이렇게 느려졌는지 원인을 분석한 다음에 이에 맞는 힌트를 적절하게 사용하면 된다. 
            
    - 메모
        
        NL은 인덱스 위주로 유도할때
        
        이중포문 돌면서
        
        조인한다고 보면 되고
        
        Hash 조인은 인덱스 사용 못하는데 데이터 많을때
        
        머 그런케이스에 쓰고
        
        대신 메모리 많이씀
        
- 서브쿼리
    - 정의
        
        다른 쿼리 내부에 포함되어 있는 SELETE 문
        
        하나의 SQL문 안에 포함되어 있는 또 다른 SQL문.
        
    - 사용이유
        
        여러번의 쿼리를 수행해야만 얻을 수 있는 결과를 하나의 중첩된 SQL문장으로 간편하게 결과를 얻을 수 있게 해줌
        
        알려지지 않은 기준을 이용한 검색을 하기 위해서
        
    - Scala subquery    SELECT절에 사용함
        
        스칼라 서브 쿼리는 하나의 레코드당 하나의 값을 리턴하는 서브쿼리 보통은 select 절에 많이 쓰지만 그 외에도 컬럼같이 올 수 있는 모든 자리에 쓸 수가 있습니다
        
    - Inline view   From절에 사용
    - 중첩 서브쿼리   Where 절에 사용
        
        
    - 단일 행 서브쿼리는 하나의 행만 반환되는 서브쿼리로, 비교연산자(=, <, <=, >=, <>)를 사용
    - 다중 행 서브쿼리는 여러 행을 반환하는 서브쿼리로, IN, ANY, ALL, EXISTS를 사용
    
    조인이 유리한지 서브쿼리가 유리한지는 옵티마이저가 알아서 판단해서 실행계획을 작성해주기때문에 서브쿼리는 성능과는 무관
    
    장점
    
    - 단점
        
        연산 비용: 매번 SELECT 문이 실행되기 때문(내용이 복잡할수록 비용이 크다)
        
        - 데이터 I/O 비용: 서브 쿼리의 결과 데이터 양이 크면 연산 결과를 저장소에 쓰기 때문
        
        - 최적화 불가능: 서브 쿼리의 결과 집합에는 인덱스나 제약조건이 없기 때문
        
    - 특징
        - Subquery는 Main Query 이전에 한 번 실행
        - 서브쿼리는 메인쿼리의 컬럼을 모두 사용할 수 있지만 메인쿼리는 서브쿼리의 컬럼사용 못함.
        - 서브쿼리를 이용할 경우 성능이 좋아지는 SQL도 존재 하지만 조인으로 작성하게 되면 OPTIMIZER에게 정확한 판단을 할 수 있도록 도와성능 문제를 예방 할 수 있음
        - SQL 작성이 쉽다는 이유 하나만으로 서브쿼리를 남용 할 경우, DB 성능 저하가 발생할 수 있음
    
- 서브쿼리 vs 조인
    
    일반조인에서 두 테이블은 평등한 관계. 반면 서브쿼리에서는 서브쿼리가 메인 쿼리에 종속되는 관계
    
    일반적으로는 JOIN 이 SUBQUERY 보다 성능이 좋습니당. DB 엔진이 JOIN 에 최적화가 더 잘되어 있거든용
    
- 인덱스
    - 정의
        
        데이터를 좀 더 빠르게 찾을 수 있도록 해주는 도구.
        
        전체 중 특정한 부분을 바로 찾을 수 있는 목차나 색인의 개념
        
        인덱스를 효과적으로 사용하려면 정규화가 되어 있어야한다. 정규화가 되어 있지 않은 테이블은 컬럼이 많으며, 이에 따라 조합할 수 있는 인덱스가 많아지게 된다. 인덱스가 많으면, 갱신 성능이 나빠지고 디스크 공간도 많아지므로 인덱스를 효과적으로 사용하려면 정규화가 잘 되어 있어야 한다.
        
    - 장점
        
        검색(특히 select) 은 속도가 무척 빨라질 수 있다./월등히 향상 (단, 항상 그런 것은 아니다)
        
        - 왜 항상 그런게 아니지?
            
            SELECT하는 경우에도 데이터 블록 수와 DB_FILE_MULTIBLOCK_READ_COUNT 값과 분포도 등에 따라 인덱스가 빠를 경우도 있고 full table scan보다 늦어지는 경우도 있음.
            
            데이터의 종류가 적은 열에는 없는 편이 낫다 (비트리)
            
            인덱스를 위한 쿼리가 거의 사용되지 않는다면 이 인덱스는 오히려 성능에 나쁜 영향을 줄 수 있다
            
        
        인덱스를 탄다고 해서 무조건 빨라지는게 아니다. 인덱스 손익 분기점이라는게 있는데 테이블이 가지고 있는 전체 데이터양의 10에서 15프로 이내의 데이터가 출력이 될때만 인덱스를 타는게 효율적이고, 그 이상이 될때에는 오히려 풀스캔 하는게 더 빠르다. 
        
        그 결과 해당 쿼리의 부하가 줄어들어서, 결국 시스템 전체의 성능이 향상된다.
        
        인덱스를 사용해서 검색을 하게되면 서버 입장에서는 적은 처리량으로 요청한 결과를 얻게 되므로, 다른 요청에 대해서도 많은 일을 할 수 있게 된다. 결과적으로 전체 시스템의 성능이 향상되는 효과도 얻게 된다. 하지만 항상 그런건 아닙니다. +단점
        
    - 단점
        
        INSERT경우에는 인덱스가 정렬이 된 상태에서 저장이 되어야하기때문에 어느 자리에 insert를 할지 찾아서 저장을 한다. 그리고 테이블에만 insert나 update를 하는게 아니라 인덱스도 똑같이 해줘야하기 때문에 두 군데에다 하니까 오히려 느려짐 
        
        인덱스가 데이터베이스 공간을 차지해서 추가적인 공간이 필요해지는데, 대략 데이터베이스 크기의 10% 정도의 추가 공간이 필요하다.
        
        처음 인덱스를 생성하는데 시간이 많이 소요될 수 있다
        
        INSERT할 경우, 이에 관계된 인덱스 테이블에서는 데이터를 정렬해야 하므로 전체적인 성능이 저하됨.
        
        인덱스를 재작성해야 할 필요가 있기에 성능에 영향을 끼칠 수 있다.
        
        데이터의 변경 작업이 자주 일어날 경우(UPDATE, DELETE, INSERT)에는 오히려 성능이 많이 나빠질 수 있다. 특히 INSERT 인덱스 분할로 인해 INSERT작업이 일어날 떄 성능이 느려질 수 있다. 비어있는 블록을 한 개 확보한 후에, 그 다음 리프 블록의 데이터를 적절히 나누게 됨. → 새로운 블록 할당+인덱스 분할.
        
        - 왜죠?
            
            인덱스가 있고, 데이터를 많이 삽입하게 되면 데이터 블록이 추가되고 인덱스 분할이 일어나기때문에 성능이 느려집니다
            
        
        인덱스가 있으면 데이터 블록 추가+인덱스 분할로 인해 성능이 느림
        
    - 인덱스 분할
        
        인덱스는 정렬되어야 한다는 점 때문에 이미 생성된 구조에 새로운 로우가 삽입되면 기존의 위치에 파고 들어감
        
    - 만드는 기준
        
        테이블의 데이터 구성이 어떻게 되었는지, 어떠한 조회를 많이 사용하는지 등에 따라서 인덱스를 생성
        
        어떤 컬럼을 조합해서 인덱스를 작성할 것인지, 즉 어떻게 컬럼을 조합해야 조회, 갱신의 모든 성능을 높일 수 있는지에 대한 논의
        
    - 인덱스를 설계 한다는 것
    - 인덱스 삭제 시
        
        데이터를 삭제했을 때 테이블의 로우는 제거되지만 인덱스의 로우는 단지 삭제되었음을 표시하므로 그 자리에 인덱스 로우가 추가되지 않을 경우 저장공간의 낭비뿐 아니라 스캔해야 할 블록이 증가함
        
        WHERE절에 사용되더라도 자주 사용해야 가치가 있다
        
    - 특징
        
        인덱스 컬럼을 기준으로 sorting이 되어서 저장이 되어있음
        
        인덱스에서 먼저 데이터들을 찾은 다음에 그 테이블로 매핑된 곳을 가서 나머지 데이터들을 꺼내오는 방식.
        
        인덱스가 해당 테이블의 데이터 블럭의 주소를 가지고 있음. 블럭에는 테이블의 데이터들이 로우 단위로 저장되어있음 
        
        특정 조건부터 스캔하기때문에 WHERE절에 자주 등장하는 컬럼을 인덱스로 설정해주면 효율적
        
        order by절에 자주 등장하는 컬럼을 인덱스로 지정해놓으면 인덱스는 sorting이 되어서 저장되어 있다고 했기 때문에 별도로 order by를 수행할 필요 없이 인덱스에서 바로 꺼내서 출력을 하면 되니까 효율적
        
        단일 컬럼으로 구성할 수도 있지만 여러 컬럼을 조합해서 결합 인덱스로 구성할 수도 있다. 이럴 경우에는 select절에 등장하는 컬럼들을 잘 조합을해서 인덱스로 구성을 해 놓으면 별도로 테이블에가서 데이터를 꺼내올 필요 없이 인덱스만 스캔을해서 바로 출력을 하면 되니까 되게 빠르다. 
        
        결합인덱스같은 경우에는 컬럼의 분별력과 선두 위치 여부는 상관이 없습니다. 오히려 분별력이 낮은 컬럼이 선두에 위치하는 것이 index skip scan 측면에선 더 유리
        
        결합인덱스의 경우 상황에 따라 순서가 달라지지만 단일 인덱스는 확실히 분별력이 높은 컬럼으로 설정하는게 유리
        
        - 애써 인덱스를 생성해놓고 SQL을 잘못 작성을해서 무용지물이 되는 경우도 있다.
            1. 인덱스 컬럼올 가공
            ex) WHERE SUBSTR([ORDER.NO](http://order.no/), 1, 4) = '2019'
            > WHERE ORDER NO LIKE '2019%'
            2. 인덕스 컬럼의 묵시적 형변환 (같은 타입으로 비교해야 함)
            ex) WHERE REG.DATE= '20190730'
            WHERE REG DATE= TO DATE('20190730'. 'YYYYMMDD ')
            3. 인덕스 컬럼 부정형 비교
            ex) WHERE MEM.TYPE ! = 'lO '
            ) WHERE MEM.TYPE IN ('20'. '30')
            4. LIKE 연산자 샤용 시 %가 앞에 위지
            5. OR 조건 사용→ UNION ALL로 대체
        - 인덱스 스캔방식
            
            index full scan - 어떤 시작점부터 특정범위를 스캔하는 방식
            
            index skip scan
            
            index fast full scan
            
        
        인덱스는 열 단위에 생성된다
        
        WHERE절에 사용되는 열에 인덱스를 만들어야 한다
        
        데이터의 중복도가 높은 열은 인덱스를 만들어도 별 효과가 없다. 비트맵이냐 B-Tree에 따라 다름
        
        JOIN에 자주 사용되는 열에는 인덱스를 생성해 주는 것이 좋다
        
        INSERT UPDATE DELETE가 얼마나 자주 일어나는 지를 고려해야 한다
        
        사용하지 않는 인덱스는 제거하자
        
        오라클책
        
        일반적으로 테이블 전체로서의 15% 의 데이터를 줘야 할 때 인덱스를 생성 한다
        
        물론 15%는 정해진 것은 아니며 케이블 건수 데이터 분포 정도에 따라 달라진다
        
        테이블 건수가 적다면 구지 인덱스를 만들 필요가 없다
        
        데이터 추출을 위해 테이블이나 인덱스를 탐색하는 것을 스킨이라고 하는데 테이블 건수가 적으면 인덱스를 경리 하기 보다 테이블 전체를 스캔 하는 것이 빠르다
        
        데이터에 유일성 정도가 좋거나 범위가 넓은 값을 가진 컬럼을 index로 만드는 것이 좋다
        
        NULL이 많이 포함된 칼럼은 index 컬럼으로 만들기 적당치 않다
        
        결합 인덱스를 만들 때는 칼럼의 순서가 중요하다
        
        보통 자주 사용되는 컬럼을 순서상 앞에 두는 것이 좋다
        
        테이블에 만들 수 있는 index 수의 제한은 없으나 너무 많이 만들면 오히려 성능 부하가 발생한다
        
    - 결과
        
        인덱스는 한 번 생성했다고 내버려 두는 것이 아니라 잘 활용되는 지를 살펴서 활용이 되지않으면 삭제하고, 사용하는 인덱스는 주기적으로 ALTER INDEX 인덱스이름 REBUILD로 인덱스를 재구성해서 시스템의 성능을 최상으로 유지하는 방법
        
    - OLTP    On Line Transaction Processing
        
        INSERT UPDATE DELETE 가 실시간으로 자주 발생하므로 꼭 필요한 인덱스만 최소로 생성하는 것이 바람직하다
        
    - OLAP    On Line Analytical Processing
        
        INSERT UPDATE DELETE 가 별로 사용될 일이 없으므로 되도록 인덱스를 많이 만들어도 별 문제가 되지 않는다
        
    
    인덱스를 생성하고 인덱스를 사용하는 SQL을 만들어 사용한다면, 기존보다 아주 빠른 응답 속도를 얻을 수 있다.  또한 서버 입장에서는 적은 처리량으로 요청한 결과를 얻게 되므로, 다른 요청에 대해서도 많은 일을 할 수 있게 된다. 결과적으로 전체 시스템의 성능이 향상되는 효과도 얻게 된다.
    
    테이블 생성 시에 제약 조건 Primary Key 또는 Unique를 사용하면 자동으로 인덱스가 자동 생성된다.
    
    B-Tree 구조는 데이터를 검색(SELECT)할 때 아주 뛰어난 성능을 발휘 함.
    
    인덱스는 여러 개 생성할 수가 있다. 하지만, 함부로 남용할 경우에는 오히려 시스템 성능을 떨어뜨리는 결과를 초래할 수 있으므로, 꼭 필요한 열에만 생성하는 것이 좋다.
    
    디비에 인덱스 생성해도 인덱스사용하는게 빠른지 그냥 풀스캔이 빠를지 Oracle이 알아서 판단한다
    
    데이터의 종류가 적은 열에는 인덱스를 생성하지 않는 편이 낫다.(선택도가 나쁜 데이터)
    
    중복도가 높은 열에는 B-Tree 이ㄴ덱스를 만들어도 거의 사용하지 않는다 비트맵 인덱스는 비트라는 최소 딘위를 이용해서 데이터 깂을 저장하기 때문에 데이터의 중복도가 높은 경우에 사용하면 효율적이다
    
- 정규화
    - 정의
        
        데이터가 꼬이는 것을 막기 위해 테이블을 잘게 나누는 것
        
    - 목적
        
        중복을 최소화, 이상현상 제거 ( 삽입, 삭제, 변경 )
        
        불필요한 데이터를 제거하고 데이터 저장을 논리적으로 한다.
        
    - 제1정규형 원자성
        
        원자성 - 모든 속성은 반드시 하나의 값만 가져야 한다
        
        다중값을 가진다(sns컬럼에 인스타그램, 트위터, 페이스북, 유튜브) → 제 1 정규형 위배
        
        반복 그룹을 가진다(SNS1 SNS2 SNS3 SNS4 SNS5) → 제 1 정규형 위배
        
    - 제2정규형 (2NF) 부분 종속    기본키가 2개 이상의 속성으로 이루어진 경우
        
        부분 종속 - 모든 속성은 반드시 모든 기본키에 종속되어야 한다. (기본키 일부에만 종속되어서는 안됨) → 테이블 분리
        
        주문번호 | 음료코드 | 주문수량 | 음료명
        
        음료명은 음료코드 속성에만 종속된다.
        
        - 주문이 발생하지 않으면 음료 입력 불가 → 입력 이상
        - 음료명이 변경될 경우 해당되는 주문 ROW UPDATE 필요 → 수정 이상
        - 음료 삭제 시 주문까지 삭제 → 삭제 이상
        
        → 데이터 이상 발생
        
        종속 관계가 있는 속성ㅁ나 추출해서 테이블 분리
        
        결과 - 주문과 관계없이 음료 데이터 입력, 수정 삭제가능
        
    - 제3 정규형(3NF) 이행 종속    기본키를 제외한 컬럼 간 종속성 제거
        
        기본키가 아닌 모든 속성간에는 서로 종속될 수 없다. - 테이블 분리
        
        직원번호 | 직원명 | 소속사번호 | 소속사명
        
        소속사명은 소속사 번호 속성에 종속된다
        
        → 데이터 이상 현상 발생
        
        2NF와 마찬가지로 똑같이 테이블 분리
        
    - BCNF
        
        3차 정규형을 만족하면서 모든 결정자가 후보키 집합에 속한 정규형
        
        3차 정규형으로 해결할 수 없는 이상현상을 해결가능
        
        즉, 함수 종속성이 모두 제거된 상태의 정규형. 이 이상에서 함수 종속성에 의한 무손실 분해를 할 수 없다.
        
- 반 정규화
    - 정의
        
        성능 향상을 위해 정규화를 포기하는 것. 그러나 데이터 무결성이 보장 되지 않으므로 제한적으로 사용해야 한다.
        
    1. 테이블 반정규화 - 테이블 병합/분할/추가
        
        테이블 병합 : 비즈니스 로직 상 JOIN되는 경우가 많아 통합하는 것이 성능 측면에서 유리할 경우 고려.
        
        1. 1:1 관계 테이블 병합
        2. 1:M 관계 테이블 병합
        3. 슈퍼 서브 타입 테이블 병합
        
        테이블 분할
        
        1. 수직 분할 : 컬럼 단위로 테이블을 1:1 분리
        2. 수평 분할 : ROW 단위로 테이블 분리
        
        테이블 추가
        
        1. 중복 테이블 추가
            
            타 엄무 또는 타 서버에 있는 테이블과 동일한 구조의 테이블 추가, 원격 JOIN 방지
            
        2. 통계 테이블 추가
            
            통계값을 미리 계산해서 저장하는 테이블 추가
            
        3. 이력 테이블 추가
            
            마스터 테이블에 존재하는 ROW를 트랜잭션 발생 시점에 따라 복사해두는 테이블 추가
            
        4. 부분 테이블 추가
            
            자주 조회되는 컬럼들만 별도로 모아놓은 테이블 추가 → 인싸들만 모아놓은 테이블
            
    2. 컬럼 반정규화 - 중복/파생/이력테이블 컬럼 추가
        
        중복컬럼추가
        
        - JOIN 프로세스를 줄이기 위해 중복 컬럼 추가
        - SELECT 비용은 감소하나, UPDATE 비용은 증가
        
        회원 | 주문 | 주문상품 | 배송
        
        회원번호 | 주문번호 |주문번호 | 배송번호
        
        회원명 | 회원번호 | 상품번호 | 주문번호
        
                                                         상품번호
        
                                                         회원번호
        
        파생컬럼 추가
        
        - 계산을 통해 얻어지는 결과값을 테이블에 컬럼으로 저장
        
        **주문 총금액** | 상품번호+주문수량 | 단가
        
        이력 테이블 컬럼 추가
        
        - 이력 테이블에 기능성 컬럼 추가(최신 여부, 시작일/종료일 등)
    3. 관계 반정규화 - 중복관계 추가
        
        중복관계 추가
        
        - 데이터 처리를 위해 여러 경로를 거쳐야 할 경우 관계를 중복시킴으로써 성능 개선
- 트랜잭션
    - 정의
        
        쿼리를 하나의 묶음 처리해서 만약 중간에 실행이 중단됐을 경우, 처음부터 다시 실행하는 ROLLBACK을 수행하고, 오류없이 실행을 마치면 COMMIT을 하는 실행 단위.
        
    - 사용 이유
        
        DB 서버에 여러 개의 클라이언트가 동시에 액세스 하거나 응용프로그램이 갱신을 처리하는 과정에서 중단될 수 있는 경우 등 **데이터 부정합을 방지**하고자 할 때 사용합니다.
        
        부정합이 발생하지 않으려면 프로세스를 병렬로 처리하지 않도록 하여 한 번에 하나의 프로세스만 처리하도록 하면 되는데, 이는 효율이 너무 떨어집니다.
        
        즉, 병렬로 처리할 수 밖에 없는 현실적인 상황으로 인해 부정합을 방지하고자 트랜잭션을 사용하는 것입니다.
        
    - 원자성
        
        트랜잭션이 데이터베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다는 것
        
    - 일관성
        
        트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다는 것.
        
        트랜잭션이 진행되는 동안에 데이터베이스가 변경 되더라도 업데이트된 데이터베이스로 트랜잭션이 진행되는것이 아니라, 처음에 트랜잭션을 진행 하기 위해 참조한 데이터베이스로 진행되어야 한다.
        
    - 독립성
        
        둘 이상의 트랜잭션이 동시에 실행되고 있을 경우, 어떤 하나의 트랜잭션이라도 다른 트랜잭션의 연산에 끼어 들수 없다는 점
        
        하나의 특정 트랜잭션이 완료될때까지, 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없다.
        
    - 지속성
        
        트랜잭션이 성공적으로 완료되었을 경우에 결과는 영구적으로 반영되어야 한다는 점
        
- 옵티마이저(Optimizer)
    
    SQL을 처리하는 최저비용의 경로를 생성해주는 DBMS 내부 핵심엔진
    
    옵티마이저는 많은 조인 테크닉을 가지기 때문에 조인 형태로 변환했을 때 더 나은 실행계획을 찾을 가능성이 높다.
    
    - SQL 개발자가 SQL을 작성하여 실행할 때, 옵티마이저는 SQL을 어떻게 실행할 것인지를 계획하게 된다.
    - SQL 실행 계획(Execution Plan)을 수립하고 SQL을 실행한다.
    - 옵티마이저는 SQL의 실행 계획을 수립하고 SQL을 실행하는 데이터베이스 관리 시스템의 소프트웨어이다.
    - 동일한 결과가 나오는 SQL도 어떻게 실행하느냐에 따라서 성능이 달라지기에, SQL 성능에 옵티마이저는 아주 중요한 역할을 한다.
